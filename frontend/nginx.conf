################################################################################
# Production-ready Nginx Configuration
# Purpose: Serve Vue.js SPA + Reverse Proxy to Node.js API
# Architecture: Single-origin pattern (frontend + API on same domain)
################################################################################

user nginx;
worker_processes auto;              # Auto-detect CPU cores for optimal parallelism
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

################################################################################
# EVENT PROCESSING
# Why: Defines how Nginx handles connections at the system level
################################################################################
events {
    # Allows 2048 concurrent connections per worker process
    # Calculation: 2048 × CPU cores = total capacity
    # Justification: Handles medium traffic (~10k requests/min on 4 cores)
    worker_connections 2048;
    
    # Linux kernel's efficient I/O event notification mechanism
    # Why: 40% better performance than select/poll on Linux containers
    use epoll;
    
    # Accept multiple connections simultaneously instead of one-by-one
    # Why: Reduces latency under high load (multiple users accessing SPA)
    multi_accept on;
}

################################################################################
# HTTP CONFIGURATION
################################################################################
http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # Force UTF-8 encoding for all text responses
    # Why: Vue.js app uses Unicode characters, prevents encoding issues
    charset utf-8;

    # Enhanced logging with response time for performance monitoring
    # Why: 'rt=$request_time' helps identify slow API calls through proxy
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" rt=$request_time';
    
    access_log /var/log/nginx/access.log main;

    ############################################################################
    # PERFORMANCE OPTIMIZATIONS
    # Why: Critical for serving Vite-built assets efficiently
    ############################################################################
    
    # Zero-copy file transmission (kernel → socket, bypass userspace)
    # Why: 30% faster for serving JS bundles, fonts, images
    sendfile on;
    
    # Send HTTP headers + file in one packet (requires sendfile on)
    # Why: Reduces network overhead for large Vite chunks
    tcp_nopush on;
    
    # Disable Nagle's algorithm for small packets
    # Why: Lower latency for API JSON responses
    tcp_nodelay on;
    
    # Keep TCP connections alive for 65 seconds
    # Why: Vue app makes multiple API calls, reuses same connection
    keepalive_timeout 65;
    
    # Allow 100 requests per keepalive connection
    # Why: SPA makes bursts of requests (API + assets), reduces handshakes
    keepalive_requests 100;
    
    # Maximum size for MIME types hash table
    # Why: Default is too small for modern web apps with many file types
    types_hash_max_size 2048;
    
    # Hide Nginx version in headers and error pages
    # Why: Security - prevents version-specific exploit targeting
    server_tokens off;
    
    # Buffer sizes for handling request bodies (file uploads, JSON payloads)
    client_body_buffer_size 128k;       # Handles typical form submissions
    client_max_body_size 10M;           # Max upload size (adjustable)
    client_header_buffer_size 1k;       # Standard request headers
    large_client_header_buffers 4 8k;   # For large cookies/JWT tokens

    ############################################################################
    # COMPRESSION
    # Why: Reduces bandwidth by ~70% for text assets (JS, CSS, JSON)
    ############################################################################
    gzip on;
    gzip_vary on;                       # Add 'Vary: Accept-Encoding' header
    gzip_proxied any;                   # Compress proxied API responses too
    gzip_comp_level 6;                  # Balance: CPU (6) vs compression ratio
    gzip_min_length 256;                # Skip tiny files (overhead > gain)
    
    # Compress these MIME types (NOT images - already compressed)
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json                # API responses
        application/javascript          # Vite bundles
        application/xml+rss
        font/truetype
        font/opentype
        application/vnd.ms-fontobject
        image/svg+xml;                  # SVG icons (text-based)

    ############################################################################
    # SECURITY
    # Why: Protect against common web vulnerabilities (XSS, clickjacking, etc.)
    ############################################################################
    
    # Prevent embedding in iframes (clickjacking protection)
    # Why: Vue app should only run in its own window
    add_header X-Frame-Options "SAMEORIGIN" always;
    
    # Prevent MIME-type sniffing (execute JS as image, etc.)
    # Why: Forces browsers to respect Content-Type header
    add_header X-Content-Type-Options "nosniff" always;
    
    # Enable XSS filter in older browsers (deprecated but harmless)
    # Why: Defense-in-depth, complements CSP
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Control Referer header leakage
    # Why: Don't leak internal URLs to external sites
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # Rate limiting zone: 10MB stores ~160k IP addresses
    # 10 req/s = allows typical user interaction without blocking
    # Why: Prevents API abuse (brute force, scraping, DDoS)
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    limit_req_status 429;               # HTTP 429 Too Many Requests
    
    # Connection limiting: max 10 concurrent connections per IP
    # Why: Prevents single client from hogging resources
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;

    ############################################################################
    # UPSTREAM DEFINITION
    # Why: Defines backend API server with health checking and connection pooling
    ############################################################################
    upstream api_backend {
        # Docker service name resolution (Docker DNS)
        # max_fails=3: Mark server down after 3 failed attempts
        # fail_timeout=30s: Try again after 30 seconds
        # Why: Circuit breaker pattern - protect against cascading failures
        server api:3000 max_fails=3 fail_timeout=30s;
        
        # Keep 32 idle connections to backend (connection pooling)
        # Why: Eliminates TCP handshake latency for API calls (~50ms saved)
        keepalive 32;
    }

    ############################################################################
    # SERVER BLOCK
    ############################################################################
    server {
        # Listen on IPv4 and IPv6 (dual-stack) on non-privileged port
        # Why: Port 8080 doesn't require root privileges
        listen 8080 default_server;
        listen [::]:8080 default_server;
        server_name _;
        
        root /usr/share/nginx/html;     # Vite build output copied here
        index index.html;
        
        # Limit concurrent connections per IP
        # Why: Prevents resource exhaustion from single abusive client
        limit_conn conn_limit 10;

        ########################################################################
        # STATIC ASSETS CACHING
        # Why: Vite generates content-hashed filenames (main.abc123.js)
        #      These NEVER change, so aggressive caching is safe
        ########################################################################
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp)$ {
            expires 1y;                 # Browser caches for 1 year
            add_header Cache-Control "public, immutable";
            access_log off;             # Reduce I/O (these logs aren't useful)
            try_files $uri =404;        # Fail if file doesn't exist
        }

        ########################################################################
        # HTML FILES - NO CACHING
        # Why: index.html is the entrypoint and must be fresh after deployments
        #      If cached, users would load old app version after updates
        ########################################################################
        location ~* \.html$ {
            expires -1;                 # Expire immediately
            add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        }

        ########################################################################
        # REVERSE PROXY TO API
        # Why: Single-origin architecture solves CORS issues
        #      Frontend: http://localhost:8080/
        #      API:      http://localhost:8080/api/*
        ########################################################################
        location /api/ {
            # Rate limiting: 10 req/s baseline, burst allows temporary spikes
            # nodelay: Don't delay burst requests (better UX)
            # Why: Protects API from abuse while allowing normal usage patterns
            limit_req zone=api_limit burst=20 nodelay;

            # Proxy to upstream, strip '/api' prefix
            # Example: /api/items → api:3000/items
            proxy_pass http://api_backend/;
            
            # Use HTTP/1.1 for keepalive support
            # Why: Reuse connections to backend (10x faster than HTTP/1.0)
            proxy_http_version 1.1;
            
            # WebSocket upgrade headers (future-proofing for real-time features)
            # Why: Allows WebSocket connections through proxy
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;
            
            # Forward original client information to API
            # Why: API logs see real client IP, not Nginx's internal IP
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Port $server_port;

            # Timeouts tuned for API response times
            # Why: 30s is reasonable for database queries, prevents hung connections
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;

            # Disable buffering for streaming responses
            # Why: SSE/streaming endpoints work correctly, lower latency
            proxy_buffering off;
            proxy_request_buffering off;
        }

        ########################################################################
        # HEALTH CHECK ENDPOINT
        # Why: Docker HEALTHCHECK instruction uses this to monitor container
        #      Returns 200 OK without hitting backend (pure Nginx check)
        ########################################################################
        location = /nginx-health {
            access_log off;
            default_type text/plain;
            return 200 "healthy\n";
        }

        ########################################################################
        # SPA ROUTING (CRITICAL FOR VUE ROUTER)
        # Why: Vue Router uses HTML5 history mode (/about, /items, etc.)
        #      These paths don't exist as files, so we serve index.html
        #      Vue app then handles routing client-side
        # Example: /items/42 → index.html → Vue Router renders ItemDetail
        ########################################################################
        location / {
            try_files $uri $uri/ /index.html;
        }

        ########################################################################
        # ERROR PAGES
        ########################################################################
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root /usr/share/nginx/html;
            internal;                   # Only accessible via error_page
        }
    }

    ############################################################################
    # WEBSOCKET UPGRADE MAP
    # Why: Determines Connection header value based on Upgrade header presence
    #      Required for WebSocket handshake through reverse proxy
    ############################################################################
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }
}
